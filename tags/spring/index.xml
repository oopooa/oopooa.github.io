<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring on Opoa</title><link>https://opoa.top/tags/spring/</link><description>Recent content in Spring on Opoa</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>蜀ICP备20005474号-1</copyright><lastBuildDate>Sat, 27 Aug 2022 16:22:43 +0800</lastBuildDate><atom:link href="https://opoa.top/tags/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>响应式编程 Spring Webflux 详解（二）</title><link>https://opoa.top/post/dive-into-spring-webflux-2/</link><pubDate>Sat, 27 Aug 2022 16:22:43 +0800</pubDate><guid>https://opoa.top/post/dive-into-spring-webflux-2/</guid><description>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/cover/rem-face-portrait-close.webp" alt="Featured image of post 响应式编程 Spring Webflux 详解（二）" />&lt;h2 id="hello-reactive-world">Hello Reactive World
&lt;/h2>&lt;h3 id="引入依赖">引入依赖
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/init-spring-webflux-project.webp"
loading="lazy"
alt="init-spring-webflux-project"
>&lt;/p>
&lt;p>在新建项目的时候引入 Spring Reactive Web，为了方便也引入了 Lombok。&lt;/p>
&lt;h3 id="编写-controller">编写 Controller
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@RestController&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="nd">@RequestMapping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/reactive&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">ReactiveController&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="nd">@GetMapping&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;/hello&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Mono&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">hello&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Mono&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">just&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello Reactive World&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;br>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-shell" data-lang="shell">&lt;span class="line">&lt;span class="cl">&lt;span class="o">[&lt;/span> main&lt;span class="o">]&lt;/span> o.s.b.web.embedded.netty.NettyWebServer : Netty started on port &lt;span class="m">8080&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>启动服务，可以看到程序是运行在 Netty 服务上的。&lt;/p>
&lt;h3 id="请求">请求
&lt;/h3>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/spring-webflux-hello-world-demo.webp"
loading="lazy"
alt="spring-webflux-hello-world-demo"
>&lt;/p>
&lt;p>WebFlux 提供了与之前 WebMVC 相同的一套注解来定义请求的处理，使得 Spring 使用者迁移到响应式开发方式的过程变得异常轻松。&lt;/p>
&lt;h2 id="flux-与-mono">Flux 与 Mono
&lt;/h2>&lt;p>Reactor 中的发布者 (Publisher) 由 &lt;code>Flux&lt;/code> 和 &lt;code>Mono&lt;/code> 两个类定义，它们都提供了丰富的操作符 (operator)。&lt;/p>
&lt;ul>
&lt;li>Flux: 代表一个包含 0-N 个元素的响应式序列。&lt;/li>
&lt;li>Mono: 代表一个包含 0/1 个元素的响应式序列。
可以暂时简单地把 &lt;code>Mono&lt;/code> 理解成单个对象，&lt;code>Flux&lt;/code> 理解成 List 列表对象。&lt;/li>
&lt;/ul>
&lt;p>作为 &amp;ldquo;数据流&amp;rdquo; 的发布者，&lt;code>Flux&lt;/code> 和 &lt;code>Mono&lt;/code> 都可以发出三种 &amp;ldquo;数据信号&amp;rdquo;：元素值、错误信号、完成信号，错误信号和完成信号都是终止信号，完成信号用于告知下游订阅者该数据流正常结束，错误信号终止数据流的同时将错误传递给下游订阅者。&lt;/p>
&lt;p>下图是一个 &lt;code>Flux&lt;/code> 类型的数据流，黑色箭头是时间轴。它连续发出 1 - 6 共 6 个元素值，以及一个完成新信号（图中 6 后边的加粗竖线）, 完成信号告知订阅者数据流已经结束。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/flux-graphic.webp"
loading="lazy"
alt="flux"
>&lt;/p>
&lt;p>用代码声明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">just&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">6&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下图是一个 &lt;code>Mono&lt;/code> 类型的数据流，它发出一个元素值后，又发出一个完成信号。&lt;/p>
&lt;p>用代码声明：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Mono&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">just&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>Flux&lt;/code> 和 &lt;code>Mono&lt;/code> 提供了多种创建数据流的方法，&lt;code>just&lt;/code> 是一种比较直接的声明数据流的方式，其参数就是数据元素。
还可以通过如下方式声明&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 基于数组&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">6&lt;/span>&lt;span class="p">};&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">fromArray&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 基于集合&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Arrays&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">asList&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">fromIterable&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 基于 Stream&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Stream&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">stream&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">list&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">stream&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">fromStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">stream&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过，这三种信号都不是一定要具备的：&lt;/p>
&lt;ul>
&lt;li>错误信号和完成信号都是终止信号，二者不可能同时存在。&lt;/li>
&lt;li>如果没有发出任何一个元素值，而是直接发出完成 / 错误信号，表示这是一个空数据流。&lt;/li>
&lt;li>如果没有错误信号和完成信号，那么就是一个无限数据流。&lt;/li>
&lt;/ul>
&lt;p>比如，只有完成 / 错误信号的数据流：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 只有完成信号的空数据流&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">just&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">empty&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Mono&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">empty&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 只有错误信号的数据流&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RuntimeException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;some error&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Mono&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RuntimeException&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;some error&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>空数据流有什么用呢？举个例子，当我们从响应式 DB 中获取结果的时候，就有可能为空：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Flux&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">findAll&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Mono&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">findById&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>无论是结果为空还是发生异常，都需要通过完成 / 错误信号告知订阅者，已经查询完毕，但是没有获取到值。&lt;/p>
&lt;p>&lt;strong>订阅前什么都不会发生&lt;/strong>&lt;/p>
&lt;p>数据流有了，假设我们想把每个数据元素打印出来&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">just&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">6&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可见，&lt;code>subscribe&lt;/code> 方法中的 Lambda 表达式作用在每一个元素上。&lt;code>Flux&lt;/code> 和 &lt;code>Mono&lt;/code> 提供了多个 subscribe 的重载方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 订阅并触发数据流&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">subscribe&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 订阅并指定对正常数据元素如何处理&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Consumer&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">consumer&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 订阅并定义对正常数据元素和错误信号的处理&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Consumer&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">consumer&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Consumer&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">errorConsumer&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// 订阅并定义对正常数据元素、错误信号和完成信号的处理&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Consumer&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">consumer&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Consumer&lt;/span>&lt;span class="o">&amp;lt;?&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">super&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Throwable&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">errorConsumer&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">Runnable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">completeConsumer&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>如果是订阅上边声明的 Flux&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Flux&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">just&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">4&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">6&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">err&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;已完成&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">6
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">已完成
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>举一个有错误信号的例子&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Mono&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">RuntimeException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;业务异常&amp;#34;&lt;/span>&lt;span class="p">)).&lt;/span>&lt;span class="na">subscribe&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">err&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">println&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;已完成&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出如下&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="n">java&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">lang&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">RuntimeException&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">业务异常&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>打印出了错误信号，没有输出已完成，表示没有发出完成信号。&lt;/p>
&lt;p>注意，&lt;code>Flux.just(1, 2, 3, 4, 4, 5, 6)&lt;/code> 仅仅声明了数据流，此时数据元素并未发出，只有 &lt;code>subcriber()&lt;/code> 方法调用时才会触发数据流。所以，&lt;strong>订阅前什么都不会发生&lt;/strong>。&lt;/p></description></item><item><title>响应式编程 Spring Webflux 详解（一）</title><link>https://opoa.top/post/dive-into-spring-webflux-1/</link><pubDate>Mon, 22 Aug 2022 15:36:26 +0800</pubDate><guid>https://opoa.top/post/dive-into-spring-webflux-1/</guid><description>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/cover/miku-miko-twintails-aqua-eyes-mouse.webp" alt="Featured image of post 响应式编程 Spring Webflux 详解（一）" />&lt;h1 id="简介">简介
&lt;/h1>&lt;p>Spring WebFlux 是 Spring 在 5.0 版本后提供的一套 &lt;code>非阻塞异步&lt;/code> 开发框架，它的核心是基于 Reactor 相关 API 实现的，能够运行在 Netty、Undertow 以及 3.1 + 版本的的 Servlet 容器上。&lt;/p>
&lt;h1 id="spring-webflux-与-spring-mvc">Spring WebFlux 与 Spring MVC
&lt;/h1>&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/difference-between-webflux-and-mvc.webp"
loading="lazy"
alt="difference-between-webflux-and-mvc"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>WebFlux 是异步非阻塞 IO 模型，只需少量的工作线程就能够处理并响应请求，无需阻塞等待方法返回，提高了并发处理请求的能力，即系统吞吐量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WebMVC 的实现是阻塞 IO，其容器维护一个线程池来处理每一个用户请求，线程池有限的连接数和请求阻塞的处理过程，形成了系统吞吐量的瓶颈。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="notice notice-note" >
&lt;div class="notice-title">&lt;svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512" fill="hsl(200, 65%, 65%)">&lt;path d="M504 256a248 248 0 11-496 0 248 248 0 01496 0zm-248 50a46 46 0 100 92 46 46 0 000-92zm-44-165l8 136c0 6 5 11 12 11h48c7 0 12-5 12-11l8-136c0-7-5-13-12-13h-64c-7 0-12 6-12 13z"/>&lt;/svg>&lt;/div>&lt;p>&lt;strong>Tips:&lt;/strong>
并不是说项目使用了 WebFlux 进行开发，就能发挥出非阻塞的优势，还需要第三方库的支持，比如上面的 MongoDB，Redis，需要使用他们提供的 ReactiveAPI 进行开发。&lt;/p>&lt;/div>
&lt;br>
&lt;h1 id="五种-io-模型">五种 IO 模型
&lt;/h1>&lt;p>为了便于理解 IO 模型的基本概念，我们以应用之间的消息通信举例。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/io-model1.webp"
loading="lazy"
alt="io-model"
>&lt;/p>
&lt;ol>
&lt;li>应用 A 把消息发送到 TCP 发送缓冲区。&lt;/li>
&lt;li>TCP 发送缓冲区再把消息发送出去，经过网络传递后，消息会发送到 B 服务器的 TCP 接收缓冲区。&lt;/li>
&lt;li>应用 B 从 TCP 接收缓冲区中读取属于自己的数据。&lt;/li>
&lt;/ol>
&lt;h2 id="阻塞-io-模型">阻塞 IO 模型
&lt;/h2>&lt;p>阻塞 IO 是当应用 B 发起读取数据申请时，在内核数据没有准备好之前，应用 B 会一直处于等待数据状态，直到内核把数据准备好了交给应用 B 才结束。&lt;/p>
&lt;h2 id="非阻塞-io-模型">非阻塞 IO 模型
&lt;/h2>&lt;p>非阻塞 IO 是当应用 B 发起读取数据申请时，如果内核数据没有准备好会立即告诉应用 B，不会让 B 在这里等待。
但是需要应用 B 不断发起读取数据申请，直到读取到需要的数据为止。这样会造成一定的资源浪费。&lt;/p>
&lt;h2 id="复用-io-模型">复用 IO 模型
&lt;/h2>&lt;p>&lt;strong>思考一个问题：&lt;/strong>&lt;/p>
&lt;p>如果在并发环境下，有 N 个人向应用 B 发送消息，应用 B 就需要创建多个线程去读取数据，情况如下图：&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/io-model2.webp"
loading="lazy"
alt="io-model"
>&lt;/p>
&lt;p>并发情况下服务器很可能一瞬间收到几十万的请求，应用 B 就需要创建几十万个线程去读取数据，同时因为线程不知道数据什么时候准备好，为了确保消息能即使读取到，那么这些线程自己会不断请求获取数据。&lt;/p>
&lt;p>先不说服务器能不能扛得住这么多线程，就算扛得住，这种方式也非常浪费资源，大量的线程用于读取数据，意味着能做其它事情的线程就会变少。&lt;/p>
&lt;p>那能不能提供一种方式，可以由一个线程监控多个网络请求，当有数据准备就绪之后再分配对应的线程去读取数据，这样就能节省出大量的线程资源，这个就是 IO 复用模型的思路。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/io-model3.webp"
loading="lazy"
alt="io-model"
>&lt;/p>
&lt;p>正如上图，IO 复用模型的思路就是提供了一种函数可以同时监控多个 fd 的操作，这个函数正是我们常说到的 select、poll、epoll 函数，select 函数监控的 fd 中只要有任何一个数据状态准备就绪，select 就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程再去发起请求读取数据。&lt;/p>
&lt;p>&lt;strong>总结：&lt;/strong> 复用 IO 的基本思路就是通过 slect 或 poll、epoll 来监控多 fd ，来达到不必为每个 fd 创建一个对应的监控线程，从而减少线程资源创建的目的。&lt;/p>
&lt;h2 id="信号驱动-io-模型">信号驱动 IO 模型
&lt;/h2>&lt;p>复用 IO 模型可以通过一个线程监控多个 fd，但由于是采用轮询的方式，大部分情况下的轮询都是无效的，而且随着监控的 fd 越来越多，效率也直线下降。那么能不能不要我总是去询问你数据有没有准备好，而是你数据就绪之后就通知后，由此衍生了信号驱动 IO 模型。&lt;/p>
&lt;p>信号驱动 IO 是在调用 sigaction 的时候建立一个 SIGIO 信号联系，当数据准备好之后通过 SIGIO 信号通知线程，线程收到数据就绪的状态后，再发起读取数据的请求，因为信号驱动 IO 模型下的应用线程在发出信号监控后可立即返回，不会阻塞，所以这样的方式下，一个应用线程也可以监控多个 fd。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/io-model4.webp"
loading="lazy"
alt="io-model"
>&lt;/p>
&lt;p>&lt;strong>总结：&lt;/strong> 信号驱动 IO 模型通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知，这样就可以避免大量无效的数据状态轮询操作。&lt;/p>
&lt;h2 id="异步-io-模型">异步 IO 模型
&lt;/h2>&lt;p>通过观察发现，不管是 IO 复用还是信号驱动，我们要获取数据总是要发起两个阶段的请求，第一次发送请求询问数据状态是否准备好，第二次发送请求读取数据。&lt;/p>
&lt;p>&lt;img src="https://cdn.jsdelivr.net/gh/oopooa/cdn/post/io-model5.webp"
loading="lazy"
alt="io-model"
>&lt;/p>
&lt;p>于是有人设计了一种方案，应用只需要发送一个获取数据请求，告诉内核它要读取数据后立刻返回，内核收到请求后建立一个信号联系，当数据准备就绪后，内核会主动把数据复制到用户空间，等所有操作完成之后，内核会发起一个通知告诉应用，这种一劳永逸的模式就是异步 IO 模型。&lt;/p>
&lt;p>&lt;strong>总结：&lt;/strong> 在异步 IO 的模型下，只需要发送一次读取请求就可以完成状态询问和数据拷贝的所有操作。&lt;/p></description></item></channel></rss>